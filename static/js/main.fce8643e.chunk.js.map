{"version":3,"sources":["index.js","ml/agent.js","ml/ttt.js","ml/mcts.js","ml/mctsNode.js"],"names":["agent","require","Square","props","react__WEBPACK_IMPORTED_MODULE_6___default","a","createElement","className","onClick","value","Board","i","_this","this","squares","renderSquare","React","Component","Game","_this2","Object","C_Users_Caleb_Documents_Computer_Wizard_React_ttt_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__","C_Users_Caleb_Documents_Computer_Wizard_React_ttt_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__","C_Users_Caleb_Documents_Computer_Wizard_React_ttt_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__","call","state","Array","fill","xIsNext","searchSize","search","playerX","slice","calculateWinner","move","location","x","_to2D","update","computerMove","draw","setState","pickMove","_to1D","newGame","newState","event","target","status","_this3","winner","handleClick","playAsX","playAsO","type","onChange","updateSearchSize","lines","length","_lines$i","C_Users_Caleb_Documents_Computer_Wizard_React_ttt_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__","b","c","ReactDOM","render","document","getElementById","game","mctsInit","_","brain","save","Heap","fs","net","NeuralNetwork","fromJSON","mcts","cloneDeep","init","_flipVert","inverted","rep","temp","_ref","_flipHorz","start","_ref2","_flipFull","mirror","_ref3","train","dataSize","allData","_loop","gameData","isDone","runSearch","moves","scores","Math","random","updateRoot","picked","nlargest","floor","index","rootMove","getState","forEach","push","map","moveState","input","concat","o","output","getWinner","trainingData","flatten","iterations","toJSON","JSON","stringify","writeFile","err","console","log","play","displayState","size","arguments","undefined","searchRaw","rawSearch","bestPlay","pickMoveRaw","module","exports","player","over","moveCount","getPlayer","verbose","space","xo","validMoves","nextState","focusState","position","nodeFactory","_bestChild","node","best","children","score","child","childScore","wins","plays","network","root","newNode","totalIterations","exploration","currentNode","_loop2","confidence","chosen","newConfidence","sqrt","nodePlayer","moveValue","run","bestMove","parent","reward","abs","_loop3","_loop4","childMoves"],"mappings":"6iJAIMA,SAAQC,EAAQ,KAEtB,SAASC,EAAOC,GACZ,OACIC,EAAAC,EAAAC,cAAA,UAAQC,UAAU,SACdC,QAAS,WAAQL,EAAMK,YACtBL,EAAMM,WAKbC,uLACWC,GAAG,IAAAC,EAAAC,KACZ,OAAOT,EAAAC,EAAAC,cAACJ,EAAD,CACHO,MAAOI,KAAKV,MAAMW,QAAQH,GAC1BH,QAAW,kBAAMI,EAAKT,MAAMK,QAAQG,uCAIxC,OACIP,EAAAC,EAAAC,cAAA,WACIF,EAAAC,EAAAC,cAAA,OAAKC,UAAU,aACVM,KAAKE,aAAa,GAClBF,KAAKE,aAAa,GAClBF,KAAKE,aAAa,IAEvBX,EAAAC,EAAAC,cAAA,OAAKC,UAAU,aACVM,KAAKE,aAAa,GAClBF,KAAKE,aAAa,GAClBF,KAAKE,aAAa,IAEvBX,EAAAC,EAAAC,cAAA,OAAKC,UAAU,aACVM,KAAKE,aAAa,GAClBF,KAAKE,aAAa,GAClBF,KAAKE,aAAa,YAvBnBC,IAAMC,WA8BpBC,cACF,SAAAA,EAAYf,GAAO,IAAAgB,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAP,KAAAK,IACfC,EAAAC,OAAAE,EAAA,EAAAF,CAAAP,KAAAO,OAAAG,EAAA,EAAAH,CAAAF,GAAAM,KAAAX,KAAMV,KACDsB,MAAQ,CACTX,QAASY,MAAM,GAAGC,KAAK,MACvBC,SAAS,EACTC,WAAY,KAEhB7B,EAAM8B,SACNX,EAAKY,SAAU,EARAZ,2EAWPR,GAER,IAAMG,EAAUD,KAAKY,MAAMX,QAAQkB,QAC/BJ,EAAUf,KAAKY,MAAMG,QACzB,IAAIK,EAAgBnB,KAAYA,EAAQH,GAAxC,CAGAG,EAAQH,GAAKiB,EAAU,IAAM,IAC7BA,GAAWA,EASX,IAAIM,EALJ,SAAeC,GACX,IAAIC,EAAID,EAAW,EAEnB,MAAO,CAACC,GADCD,EAAWC,GAAK,GAGlBC,CAAM1B,GACjBX,EAAMsC,OAAOJ,GACbrB,KAAK0B,aAAazB,EAASc,yCAGlBd,EAASc,GAElB,IADA,IAAIY,GAAO,EACH7B,EAAI,EAAGA,EAAI,EAAGA,IAClB,IAAIG,EAAQH,GAAI,CACZ6B,GAAO,EACP,MAGR,GAAGP,EAAgBnB,IAAY0B,EAC3B3B,KAAK4B,SAAS,CACV3B,gBAFR,CAWA,IAAIoB,EAAOlC,EAAM0C,SAAS7B,KAAKY,MAAMI,YACrC7B,EAAMsC,OAAOJ,GACbpB,EANA,SAAeoB,GACX,OAAOA,EAAK,GAAe,EAAVA,EAAK,GAKlBS,CAAMT,IAASN,EAAU,IAAM,IACvCf,KAAK4B,SAAS,CACV3B,UACAc,SAAUA,uCAKd5B,EAAM4C,UACN,IAAMC,EAAWnB,MAAM,GAAGC,KAAK,MAC/Bd,KAAK4B,SAAS,CACV3B,QAAS+B,EACTjB,SAAS,IAEb5B,EAAM8B,SACFjB,KAAKkB,SACLlB,KAAK0B,aAAaM,GAAU,qCAKhChC,KAAKkB,SAAU,EACflB,KAAK+B,4CAIL/B,KAAKkB,SAAU,EACflB,KAAK+B,mDAGQE,GACbjC,KAAK4B,SAAS,CACVZ,WAAYiB,EAAMC,OAAOtC,yCAIxB,IAEDuC,EAFCC,EAAApC,KACCqC,EAASjB,EAAgBpB,KAAKY,MAAMX,SAO1C,OAJEkC,EADEE,EACO,WAAaA,EAEb,iBAAmBrC,KAAKY,MAAMG,QAAU,IAAM,KAGrDxB,EAAAC,EAAAC,cAAA,OAAKC,UAAU,QACXH,EAAAC,EAAAC,cAAA,OAAKC,UAAU,cACXH,EAAAC,EAAAC,cAACI,EAAD,CAAOI,QAASD,KAAKY,MAAMX,QAC3BN,QAAS,SAACG,GAAD,OAAOsC,EAAKE,YAAYxC,OAErCP,EAAAC,EAAAC,cAAA,OAAKC,UAAU,aACXH,EAAAC,EAAAC,cAAA,WAAM0C,GACN5C,EAAAC,EAAAC,cAAA,WAAKF,EAAAC,EAAAC,cAAA,UAAQE,QAAS,kBAAMyC,EAAKL,YAA5B,aACLxC,EAAAC,EAAAC,cAAA,WAAKF,EAAAC,EAAAC,cAAA,UAAQE,QAAS,kBAAMyC,EAAKG,YAA5B,cACLhD,EAAAC,EAAAC,cAAA,WAAKF,EAAAC,EAAAC,cAAA,UAAQE,QAAS,kBAAMyC,EAAKI,YAA5B,cACLjD,EAAAC,EAAAC,cAAA,2BAAkBF,EAAAC,EAAAC,cAAA,SAAOgD,KAAK,OAAO7C,MAAOI,KAAKY,MAAMI,WAAY0B,SAAU,SAACT,GAAD,OAAWG,EAAKO,iBAAiBV,gBA9G/G9B,IAAMC,WA4HzB,SAASgB,EAAgBnB,GAWrB,IAVA,IAAM2C,EAAQ,CACZ,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAEA9C,EAAI,EAAGA,EAAI8C,EAAMC,OAAQ/C,IAAK,KAAAgD,EAAAvC,OAAAwC,EAAA,EAAAxC,CACnBqC,EAAM9C,GADa,GAC9BN,EAD8BsD,EAAA,GAC3BE,EAD2BF,EAAA,GACxBG,EADwBH,EAAA,GAErC,GAAI7C,EAAQT,IAAMS,EAAQT,KAAOS,EAAQ+C,IAAM/C,EAAQT,KAAOS,EAAQgD,GACpE,OAAOhD,EAAQT,GAGnB,OAAO,KAtBX0D,IAASC,OACL5D,EAAAC,EAAAC,cAACY,EAAD,MACA+C,SAASC,eAAe,kDCrK5B,IAAMC,EAAOlE,EAAQ,IACfmE,EAAWnE,EAAQ,IACnBoE,EAAIpE,EAAQ,IACZqE,EAAQrE,EAAQ,IAChBsE,EAAOtE,EAAQ,KACfuE,EAAOvE,EAAQ,KACfwE,EAAKxE,EAAQ,KAEbyE,EAAM,IAAIJ,EAAMK,cACtBD,EAAIE,SAASL,GAEb,IAAMM,EAAOR,EAAES,UAAUV,GACzBS,EAAKE,KAAKV,EAAES,UAAUX,GAAOO,GAG7B,IAAM1E,EAAQ,GAEd,SAASgF,EAAUvD,GACf,IAAMwD,EAAWZ,EAAES,UAAUrD,GAE7B,IAAK,IAAMyD,KAAOD,EAEd,IADA,IAAIE,EAAOF,EAASC,GACZvE,EAAI,EAAGA,EAAI,EAAGA,IAAK,KAAAyE,EACA,CAACD,EAAKxE,EAAE,GAAIwE,EAAKxE,IAAvCwE,EAAKxE,GADiByE,EAAA,GACbD,EAAKxE,EAAE,GADMyE,EAAA,GAI/B,OAAOH,EAGX,SAASI,EAAU5D,GACf,IAAMwD,EAAWZ,EAAES,UAAUrD,GAE7B,IAAK,IAAMyD,KAAOD,EAEd,IADA,IAAIE,EAAOF,EAASC,GACZvE,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACvB,IAAM2E,EAAU,EAAF3E,EADS4E,EAEQ,CAACJ,EAAKG,EAAM,GAAIH,EAAKG,IAAnDH,EAAKG,GAFiBC,EAAA,GAETJ,EAAKG,EAAM,GAFFC,EAAA,GAK/B,OAAON,EAGX,SAASO,EAAU/D,GACf,IAAMwD,EAAWZ,EAAES,UAAUrD,GAE7B,IAAK,IAAMyD,KAAOD,EAGd,IAFA,IAAIE,EAAOF,EAASC,GAEZvE,EAAI,EAAGA,EAAIwE,EAAKzB,OAAO,EAAG/C,IAAK,CACnC,IAAM8E,EAASN,EAAKzB,OAAS/C,EAAI,EADE+E,EAET,CAACP,EAAKM,GAASN,EAAKxE,IAA7CwE,EAAKxE,GAF6B+E,EAAA,GAEzBP,EAAKM,GAFoBC,EAAA,GAK3C,OAAOT,EAGXjF,EAAM2F,MAAQ,WACV,IAAIC,EAAW,IACXC,EAAU,GAFOC,EAAA,WAOjB,IAFA,IAAIC,EAAW,IAER5B,EAAK6B,UAAU,CAClBnB,EAAKoB,UAAU,KACf,IAAIC,EAAQrB,EAAKsB,SACjB,GAAGD,EAAMxC,OAAS,GAAK0C,KAAKC,SAAW,GACnCxB,EAAKyB,iBACF,CAEH,IAGIC,EAHM/B,EAAKgC,SAASN,EAAO,EAAG,SAAC7F,EAAGwD,GAClC,OAAOxD,EAAEI,MAAQoD,EAAEpD,QAEN2F,KAAKK,MAAsB,EAAhBL,KAAKC,WAAeK,MAEhD7B,EAAKyB,WAAWC,GAEpBpC,EAAK7B,OAAOuC,EAAK8B,YACjB,IAAMlF,EAAQ0C,EAAKyC,WACG,CAACnF,EAAO4D,EAAU5D,GAAQuD,EAAUvD,GAAQ+D,EAAU/D,IAC7DoF,QAAQ,SAAApG,GACnBsF,EAASe,KAAKrG,KAKtBoF,EAAQiB,KAAKf,EAASgB,IAAI,SAAAC,GACtB,MAAO,CACHC,MAAO5C,EAAE6C,OAAOF,EAAU5E,EAAG4E,EAAUG,GACvCC,OAAQ,EAAEjD,EAAKkD,YAAc,GAAK,OAG1ClD,EAAKvB,UACLiC,EAAKE,KAAKV,EAAES,UAAUX,GAAOO,IAjCjC,GAAGoB,YAkCOF,EAAW,GAErB,IAAI0B,EAAejD,EAAEkD,QAAQ1B,GAG7BnB,EAAIiB,MAAM2B,EAAc,CACpBE,WAAY,MAIpBxH,EAAMuE,KAAO,WAET,IAAIA,EAAOG,EAAI+C,SAGflD,EAAOmD,KAAKC,UAAUpD,GACtBE,EAAGmD,UAAU,cAAerD,EAAM,OAAQ,SAAUsD,GAChD,GAAIA,EAEA,OADAC,QAAQC,IAAI,uDACLD,QAAQC,IAAIF,GAGvBC,QAAQC,IAAI,oBAKpB/H,EAAMgI,KAAO,WACT,MAAO7D,EAAK6B,UACRnB,EAAKoB,UAAU,KACfpB,EAAKyB,aACLnC,EAAK7B,OAAOuC,EAAK8B,YACjBmB,QAAQC,IAAI5D,EAAK8D,iBAKzBjI,EAAMsC,OAAS,SAASJ,GACpB,IAAGiC,EAAK6B,SAAR,CAKA,IAFA,IAAIE,EAAQrB,EAAKsB,SACbO,GAAS,EACL/F,EAAI,EAAGA,EAAIuF,EAAMxC,OAAQ/C,IAC7B,GAAIuF,EAAMvF,GAAGuB,KAAK,IAAMA,EAAK,IAAMgE,EAAMvF,GAAGuB,KAAK,IAAMA,EAAK,GAAI,CAC5DwE,EAAQR,EAAMvF,GAAG+F,MACjB,MAGR7B,EAAKyB,WAAWI,GAChBvC,EAAK7B,OAAOJ,KAGhBlC,EAAM8B,OAAS,WAAqB,IAAZoG,EAAYC,UAAAzE,OAAA,QAAA0E,IAAAD,UAAA,GAAAA,UAAA,GAAL,IAC3BtD,EAAKoB,UAAUiC,IAGnBlI,EAAMqI,UAAY,WAAqB,IAAZH,EAAYC,UAAAzE,OAAA,QAAA0E,IAAAD,UAAA,GAAAA,UAAA,GAAL,IAC9BtD,EAAKyD,UAAUJ,IAGnBlI,EAAM0C,SAAW,WAAqB,IAAZwF,EAAYC,UAAAzE,OAAA,QAAA0E,IAAAD,UAAA,GAAAA,UAAA,GAAL,IAC7B,IAAGhE,EAAK6B,SAIR,OADAnF,KAAKiB,OAAOoG,GACLrD,EAAK0D,YAGhBvI,EAAMwI,YAAc,WAAqB,IAAZN,EAAYC,UAAAzE,OAAA,QAAA0E,IAAAD,UAAA,GAAAA,UAAA,GAAL,IAChC,IAAGhE,EAAK6B,SAIR,OADAnF,KAAKwH,UAAUH,GACRrD,EAAK0D,YAGhBvI,EAAM4C,QAAU,WACZuB,EAAKvB,UACLiC,EAAKE,KAAKV,EAAES,UAAUX,GAAOO,IAGjC+D,EAAOC,QAAU1I,sBChLjB,IAAMqE,EAAIpE,EAAQ,IAEZkE,EAAO,CACTwE,OAAQ,EACRC,MAAM,EACN1F,OAAQ,EACR2F,UAAW,EACXpH,MAAO,CACHW,EAAGV,MAAM,GAAGC,KAAK,GACjBwF,EAAGzF,MAAM,GAAGC,KAAK,KA6BzB,SAASgB,EAAMT,GACX,OAAOA,EAAK,GAAe,EAAVA,EAAK,GAI1B,SAASG,EAAMF,GACX,IAAIC,EAAID,EAAW,EAEnB,MAAO,CAACC,GADCD,EAAWC,GAAG,GAhC3B+B,EAAKvB,QAAU,WACX/B,KAAKY,MAAMW,EAAIV,MAAM,GAAGC,KAAK,GAC7Bd,KAAKY,MAAM0F,EAAIzF,MAAM,GAAGC,KAAK,GAC7Bd,KAAK8H,OAAS,EACd9H,KAAK+H,MAAO,EACZ/H,KAAKqC,OAAS,EACdrC,KAAKgI,UAAY,GAGrB1E,EAAKyC,SAAW,WACZ,OAAO/F,KAAKY,OAGhB0C,EAAK2E,UAAY,WACb,OAAOjI,KAAK8H,QAGhBxE,EAAK6B,OAAS,WACV,OAAOnF,KAAK+H,MAEhBzE,EAAKkD,UAAY,WACb,OAAOxG,KAAKqC,QAgBhBiB,EAAK8D,aAAe,WAAW,IAAArH,EAAAC,KACvBkI,EAAU,GAUd,OATAlI,KAAKY,MAAMW,EAAEyE,QAAQ,SAACmC,EAAOrI,GAEzB,IAAIsI,EAAgB,IAAVD,EAAc,IAA2B,IAApBpI,EAAKa,MAAM0F,EAAExG,GAAW,IAAM,IAE7DoI,GAAWpI,EAAI,EAAI,IAAMsI,EAAK,IAAM,IAAMA,EAAK,IAE/CF,GAAWpI,EAAE,GAAK,EAAI,KAAO,MAG1BoI,GAIX5E,EAAK+E,WAAa,WAKd,IAHA,IAAIhD,EAAQ,GAGJvF,EAAI,EAAGA,EAAI,EAAGA,IAElB,GAAsB,GAAnBE,KAAKY,MAAMW,EAAEzB,IAA8B,GAAnBE,KAAKY,MAAM0F,EAAExG,GAAS,CAE7C,IAAIwI,EAAY9E,EAAES,UAAUjE,KAAKY,OACd,IAAhBZ,KAAK8H,OACJQ,EAAU/G,EAAEzB,GAAK,EAEjBwI,EAAUhC,EAAExG,GAAK,EAIrB,IAAIuB,EAAOG,EAAM1B,GAGjBuF,EAAMY,KAAK,CACP5E,KAAMA,EACNT,MAAO0H,IAInB,OAAOjD,GAIX/B,EAAK7B,OAAS,SAASJ,GAEnB,IACIkH,EADAC,EAAW1G,EAAMT,GA8BrB,OA3BIkH,EADc,GAAfvI,KAAK8H,OACS9H,KAAKY,MAAMW,EAEXvB,KAAKY,MAAM0F,GAEjBkC,GAAY,EAIvBxI,KAAK+H,KAAwD,GAAjDQ,EAAWzG,EAAM,EAAET,EAAK,GAAK,GAAG,EAAGA,EAAK,OAA+D,GAAjDkH,EAAWzG,EAAM,EAAET,EAAK,GAAK,GAAG,EAAGA,EAAK,MAErGrB,KAAK+H,OACN/H,KAAK+H,KAAwD,GAAjDQ,EAAWzG,EAAM,CAACT,EAAK,IAAKA,EAAK,GAAK,GAAG,MAA8D,GAAjDkH,EAAWzG,EAAM,CAACT,EAAK,IAAKA,EAAK,GAAK,GAAG,MAG3GrB,KAAK+H,MAAQS,EAAS,GAAK,IAC3BxI,KAAK+H,KAAyB,GAAjBQ,EAAW,IAA4B,GAAjBA,EAAW,IAA4B,GAAjBA,EAAW,IAA8B,GAAjBA,EAAW,IAA4B,GAAjBA,EAAW,IAA4B,GAAjBA,EAAW,IAGxIvI,KAAK+H,KAIL/H,KAAKqC,OAASrC,KAAK8H,OAHnB9H,KAAK+H,KAAyB,GAAlB/H,KAAKgI,UAMrBhI,KAAK8H,QAAU9H,KAAK8H,OACpB9H,KAAKgI,YACEhI,KAAK+H,MAGhBH,EAAOC,QAAUvE,sBCnIjB,IAAMmF,EAAcrJ,EAAQ,IACtBoE,EAAIpE,EAAQ,IAGZ4E,EAAO,GA2Kb,SAAS0E,EAAWC,GAChB,IAAIC,EAAOD,EAAKE,SAAS,GACrBC,EAAQ,EAQZ,OAPAH,EAAKE,SAAS7C,QAAQ,SAAA+C,GAClB,IAAIC,EAAaD,EAAMJ,KAAKM,KAAOF,EAAMJ,KAAKO,MAC3CF,EAAaF,IACZF,EAAOG,EACPD,EAAQE,KAGTJ,EApLX5E,EAAKE,KAAO,SAASZ,EAAM6F,GACvBnJ,KAAKsD,KAAOA,EACZtD,KAAKoJ,KAAOX,EAAYY,QAAQ,KAAM,KAAM/F,EAAKyC,WAAYzC,EAAK+E,cAClErI,KAAK6D,IAAMsF,GAIfnF,EAAKoB,UAAY,WAAoD,IAAArF,EAAAC,KAA3CsJ,EAA2ChC,UAAAzE,OAAA,QAAA0E,IAAAD,UAAA,GAAAA,UAAA,GAAzB,IAAMiC,EAAmBjC,UAAAzE,OAAA,QAAA0E,IAAAD,UAAA,GAAAA,UAAA,GAAL,IACxDX,EAAa,EADgD1B,EAAA,WAI7D,IAAIuE,EAAczJ,EAAKqJ,KACnBC,GAAU,EACV/F,EAAOE,EAAES,UAAUlE,EAAKuD,MANiCmG,EAAA,WAUzD,GAAGnG,EAAK6B,SACJ,cAGJ,IAAIuE,GAAc,EACdC,OAAM,EACVH,EAAYX,SAAS7C,QAAQ,SAAA+C,GACzB,IAAGM,EAEH,GAAiB,MAAdN,EAAMJ,KAELrF,EAAK7B,OAAOsH,EAAM1H,MAClB0H,EAAMJ,KAAOF,EAAYY,QAAQG,EAAaT,EAAM1H,KAAMiC,EAAKyC,WAAYzC,EAAK+E,cAChFgB,GAAU,EACVM,EAASZ,EAAMJ,SACZ,CAEH,IAAIiB,EAAgBb,EAAMJ,KAAKM,KAAOF,EAAMJ,KAAKO,MAC7CK,EAAchE,KAAKsE,KAAKtE,KAAK2B,IAAIsC,EAAYN,OAASH,EAAMJ,KAAKO,OAClEU,EAAgBF,IACfC,EAASZ,EAAMJ,KACfe,EAAaE,MAIzBJ,EAAcG,EACVN,GACA/F,EAAK7B,OAAOkI,EAAOtI,OA5B3B,EAAG,cAAAoI,IAEK,aA4BCJ,GAMT,IAHA,IAAIS,EAAaxG,EAAK2E,aAGf3E,EAAK6B,UAAU,CAiBlB,IAfA,IAAIE,EAAQ/B,EAAK+E,aACb0B,EAAY1E,EAAMa,IAAI,SAAA7E,GACtB,IAAI+E,EAAQ5C,EAAE6C,OAAOhF,EAAKT,MAAMW,EAAGF,EAAKT,MAAM0F,GAC1CC,EAASxG,EAAK8D,IAAImG,IAAI5D,GAS1B,MAPoB,iBAAVG,IACNA,EAASA,EAAO,IAGG,GAApBjD,EAAK2E,cACJ1B,EAAS,EAAIA,GAEVA,IAEP0D,EAAW,EACPnK,EAAI,EAAGA,EAAIiK,EAAUlH,OAAQ/C,IAC7BiK,EAAUjK,GAAKiK,EAAUE,KACzBA,EAAWnK,GAGnBwD,EAAK7B,OAAO4D,EAAM4E,GAAU5I,MAIhC,GAAuB,IAApBiC,EAAKkD,YACJ,GACIgD,EAAYN,OAAS,EACrBM,EAAYP,MAAQ,GACpBO,EAAcA,EAAYU,aACP,MAAfV,OACL,CACH,IAAIW,EAAS7G,EAAKkD,aAAesD,EAAa,EAAI,EAClD,GACIN,EAAYN,OAAS,EACrBM,EAAYP,MAAQkB,EACpBA,EAAS5E,KAAK6E,IAAID,EAAS,GAC3BX,EAAcA,EAAYU,aACP,MAAfV,KAjFhB,GAAGvE,YAoFO0B,EAAa2C,IAI3BtF,EAAKyD,UAAY,WAAoD,IAAAnH,EAAAN,KAA3CsJ,EAA2ChC,UAAAzE,OAAA,QAAA0E,IAAAD,UAAA,GAAAA,UAAA,GAAzB,IAAMiC,EAAmBjC,UAAAzE,OAAA,QAAA0E,IAAAD,UAAA,GAAAA,UAAA,GAAL,IACxDX,EAAa,EADgD0D,EAAA,WAI7D,IAAIb,EAAclJ,EAAK8I,KACnBC,GAAU,EACV/F,EAAOE,EAAES,UAAU3D,EAAKgD,MANiCgH,EAAA,WAUzD,GAAGhH,EAAK6B,SACJ,cAGJ,IAAIuE,GAAc,EACdC,OAAM,EACVH,EAAYX,SAAS7C,QAAQ,SAAA+C,GACzB,IAAGM,EAEH,GAAiB,MAAdN,EAAMJ,KAELrF,EAAK7B,OAAOsH,EAAM1H,MAClB0H,EAAMJ,KAAOF,EAAYY,QAAQG,EAAaT,EAAM1H,KAAMiC,EAAKyC,WAAYzC,EAAK+E,cAChFgB,GAAU,EACVM,EAASZ,EAAMJ,SACZ,CAEH,IAAIiB,EAAgBb,EAAMJ,KAAKM,KAAOF,EAAMJ,KAAKO,MAC7CK,EAAchE,KAAKsE,KAAKtE,KAAK2B,IAAIsC,EAAYN,OAASH,EAAMJ,KAAKO,OAClEU,EAAgBF,IACfC,EAASZ,EAAMJ,KACfe,EAAaE,MAIzBJ,EAAcG,EACVN,GACA/F,EAAK7B,OAAOkI,EAAOtI,OA5B3B,EAAG,cAAAiJ,IAEK,aA4BCjB,GAMT,IAHA,IAAIS,EAAaxG,EAAK2E,aAGf3E,EAAK6B,UAAU,CAElB,IAAME,EAAQ/B,EAAK+E,aACb3C,EAASH,KAAKK,MAAML,KAAKC,SAAWH,EAAMxC,QAChDS,EAAK7B,OAAO4D,EAAMK,GAAQrE,MAI9B,GAAuB,IAApBiC,EAAKkD,YACJ,GACIgD,EAAYN,OAAS,EACrBM,EAAYP,MAAQ,GACpBO,EAAcA,EAAYU,aACP,MAAfV,OACL,CACH,IAAIW,EAAS7G,EAAKkD,aAAesD,EAAa,EAAI,EAClD,GACIN,EAAYN,OAAS,EACrBM,EAAYP,MAAQkB,EACpBA,EAAS5E,KAAK6E,IAAID,EAAS,GAC3BX,EAAcA,EAAYU,aACP,MAAfV,KA/DhB,GAAGa,YAkEO1D,EAAa2C,IAiB3BtF,EAAK0D,SAAW,WACZ,OAAOgB,EAAW1I,KAAKoJ,MAAM/H,MAIjC2C,EAAKsB,OAAS,WACV,OAAOtF,KAAKoJ,KAAKP,SAAS3C,IAAI,SAAC6C,EAAOlD,GAClC,MAAO,CACHjG,MAAOmJ,EAAMJ,KAAKM,KAAOF,EAAMJ,KAAKO,MACpCrD,QACAxE,KAAM0H,EAAM1H,SAMxB2C,EAAKyB,WAAa,WAAqB,IAAZsD,EAAYzB,UAAAzE,OAAA,QAAA0E,IAAAD,UAAA,GAAAA,UAAA,IAAH,EAG5BtH,KAAKoJ,KADNL,EAAQ,EACKL,EAAW1I,KAAKoJ,MAAMT,KAEtB3I,KAAKoJ,KAAKP,SAASE,GAAOJ,KAI1C3I,KAAKsD,KAAK7B,OAAOzB,KAAKoJ,KAAK/H,MAG3BrB,KAAKoJ,KAAKc,OAAS,MAGvBlG,EAAK8B,SAAW,WACZ,OAAO9F,KAAKoJ,KAAK/H,MAGrBuG,EAAOC,QAAU7D,oBC9NjB,IAAMyE,EAAc,CACpBA,QAAsB,SAACyB,EAAQ7I,EAAMT,EAAO2J,GACxC,IAAM5B,EAAO,CACTtH,OACAT,QACAsI,MAAO,EACPD,KAAM,EACNiB,UAQJ,OAJAvB,EAAKE,SAAW0B,EAAWrE,IAAI,SAAC7E,GAC5B,MAAO,CAACA,KAAMA,EAAKA,KAAMsH,KAAM,QAG5BA,IAGXf,EAAOC,QAAUY","file":"static/js/main.fce8643e.chunk.js","sourcesContent":["import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\n\r\nconst agent = require('./ml/agent.js');\r\n\r\nfunction Square(props) {\r\n    return (\r\n        <button className=\"square\"\r\n            onClick={() => { props.onClick() }}>\r\n            {props.value}\r\n        </button>\r\n    );\r\n}\r\n\r\nclass Board extends React.Component {\r\n    renderSquare(i) {\r\n        return <Square \r\n            value={this.props.squares[i]} \r\n            onClick = {() => this.props.onClick(i)} />;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className=\"board-row\">\r\n                    {this.renderSquare(0)}\r\n                    {this.renderSquare(1)}\r\n                    {this.renderSquare(2)}\r\n                </div>\r\n                <div className=\"board-row\">\r\n                    {this.renderSquare(3)}\r\n                    {this.renderSquare(4)}\r\n                    {this.renderSquare(5)}\r\n                </div>\r\n                <div className=\"board-row\">\r\n                    {this.renderSquare(6)}\r\n                    {this.renderSquare(7)}\r\n                    {this.renderSquare(8)}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nclass Game extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            squares: Array(9).fill(null),\r\n            xIsNext: true,\r\n            searchSize: 1000\r\n        };\r\n        agent.search();\r\n        this.playerX = true;\r\n    }\r\n\r\n    handleClick(i) {\r\n        // WHOMANZ\r\n        const squares = this.state.squares.slice();\r\n        let xIsNext = this.state.xIsNext;\r\n        if (calculateWinner(squares) || squares[i]) {\r\n            return;\r\n        }\r\n        squares[i] = xIsNext ? 'X' : 'O';\r\n        xIsNext = !xIsNext;\r\n\r\n        // COMPUTER\r\n        // converts single location to 2 coordinates [0-2][0-2]\r\n        function _to2D(location) {\r\n            let x = location % 3;\r\n            let y = (location - x) / 3;\r\n            return [x, y];\r\n        }\r\n        let move = _to2D(i);\r\n        agent.update(move);\r\n        this.computerMove(squares, xIsNext);\r\n    }\r\n\r\n    computerMove(squares, xIsNext) {\r\n        let draw = true;\r\n        for(let i = 0; i < 9; i++) {\r\n            if(!squares[i]) {\r\n                draw = false;\r\n                break;\r\n            }\r\n        }\r\n        if(calculateWinner(squares) || draw) {\r\n            this.setState({\r\n                squares\r\n            });\r\n            return;\r\n        }\r\n        // converts 2 coordinates to single location (0-8)\r\n        function _to1D(move) {\r\n            return move[0] + move[1] * 3;\r\n        }\r\n\r\n        let move = agent.pickMove(this.state.searchSize);\r\n        agent.update(move);\r\n        squares[_to1D(move)] = xIsNext ? 'X' : 'O';\r\n        this.setState({\r\n            squares,\r\n            xIsNext: !xIsNext\r\n        });\r\n    }\r\n\r\n    newGame() {\r\n        agent.newGame();\r\n        const newState = Array(9).fill(null)\r\n        this.setState({\r\n            squares: newState,\r\n            xIsNext: true\r\n        });\r\n        agent.search(); // initial search of 100 so it can update root without error\r\n        if(!this.playerX) {\r\n            this.computerMove(newState, true);\r\n        }\r\n    }\r\n\r\n    playAsX() {\r\n        this.playerX = true;\r\n        this.newGame();\r\n    }\r\n\r\n    playAsO() {\r\n        this.playerX = false;\r\n        this.newGame();\r\n    }\r\n\r\n    updateSearchSize(event) {\r\n        this.setState({\r\n            searchSize: event.target.value\r\n        });\r\n    }\r\n\r\n    render() {\r\n        const winner = calculateWinner(this.state.squares);\r\n        let status;\r\n        if (winner) {\r\n          status = 'Winner: ' + winner;\r\n        } else {\r\n          status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');\r\n        }\r\n        return (\r\n            <div className=\"game\">\r\n                <div className=\"game-board\">\r\n                    <Board squares={this.state.squares}\r\n                    onClick={(i) => this.handleClick(i)}/>\r\n                </div>\r\n                <div className=\"game-info\">\r\n                    <div>{status}</div>\r\n                    <div><button onClick={() => this.newGame()}>New Game</button></div>\r\n                    <div><button onClick={() => this.playAsX()}>Play As X</button></div>\r\n                    <div><button onClick={() => this.playAsO()}>Play As O</button></div>\r\n                    <div>Search Size: <input type=\"text\" value={this.state.searchSize} onChange={(event) => this.updateSearchSize(event)}/></div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(\r\n    <Game />,\r\n    document.getElementById('root')\r\n);\r\n\r\nfunction calculateWinner(squares) {\r\n    const lines = [\r\n      [0, 1, 2],\r\n      [3, 4, 5],\r\n      [6, 7, 8],\r\n      [0, 3, 6],\r\n      [1, 4, 7],\r\n      [2, 5, 8],\r\n      [0, 4, 8],\r\n      [2, 4, 6],\r\n    ];\r\n    for (let i = 0; i < lines.length; i++) {\r\n      const [a, b, c] = lines[i];\r\n      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\r\n        return squares[a];\r\n      }\r\n    }\r\n    return null;\r\n  }","// Agent\r\nconst game = require('./ttt.js');\r\nconst mctsInit = require('./mcts.js');\r\nconst _ = require('lodash');\r\nconst brain = require('brain.js');\r\nconst save = require('./save.json');\r\nconst Heap = require('heap');\r\nconst fs = require('fs');\r\n\r\nconst net = new brain.NeuralNetwork();\r\nnet.fromJSON(save);\r\n\r\nconst mcts = _.cloneDeep(mctsInit);\r\nmcts.init(_.cloneDeep(game), net);\r\n\r\n// main object\r\nconst agent = {};\r\n\r\nfunction _flipVert(state) {\r\n    const inverted = _.cloneDeep(state);\r\n    // state.x and state.o\r\n    for (const rep in inverted) {\r\n        let temp = inverted[rep];\r\n        for(let i = 0; i < 3; i++) {\r\n            [temp[i], temp[i+6]] = [temp[i+6], temp[i]];\r\n        }\r\n    }\r\n    return inverted;\r\n}\r\n\r\nfunction _flipHorz(state) {\r\n    const inverted = _.cloneDeep(state);\r\n    // state.x and state.o\r\n    for (const rep in inverted) {\r\n        let temp = inverted[rep];\r\n        for(let i = 0; i < 3; i++) {\r\n            const start = i*3;\r\n            [temp[start], temp[start+2]] = [temp[start+2], temp[start]];\r\n        }\r\n    }\r\n    return inverted;\r\n}\r\n\r\nfunction _flipFull(state) {\r\n    const inverted = _.cloneDeep(state);\r\n    // state.x and state.o\r\n    for (const rep in inverted) {\r\n        let temp = inverted[rep];\r\n        // mirror\r\n        for(let i = 0; i < temp.length/2; i++) {\r\n            const mirror = temp.length - i - 1;\r\n            [temp[i], temp[mirror]] = [temp[mirror], temp[i]];\r\n        }\r\n    }\r\n    return inverted;\r\n}\r\n\r\nagent.train = function() {\r\n    let dataSize = 100;\r\n    let allData = [];\r\n    // generate data\r\n    do {\r\n        let gameData = [];\r\n        // play game\r\n        while(!game.isDone()) {\r\n            mcts.runSearch(500);\r\n            let moves = mcts.scores();\r\n            if(moves.length < 3 || Math.random() < .5) {\r\n                mcts.updateRoot();\r\n            } else {\r\n                // pick from top 3\r\n                let top = Heap.nlargest(moves, 3, (a, b) => {\r\n                    return a.value - b.value;\r\n                })\r\n                let picked = top[Math.floor(Math.random() * 3)].index;\r\n                \r\n                mcts.updateRoot(picked);\r\n            }\r\n            game.update(mcts.rootMove());\r\n            const state = game.getState();\r\n            let  gameSymmetries = [state, _flipHorz(state), _flipVert(state), _flipFull(state)];\r\n            gameSymmetries.forEach(value => {\r\n                gameData.push(value);\r\n            });\r\n            \r\n        }\r\n        // allData = [[example, example, ...], ...]\r\n        allData.push(gameData.map(moveState => {\r\n            return {\r\n                input: _.concat(moveState.x, moveState.o),\r\n                output: [(game.getWinner() + 1) / 2] // [-1, 0, 1] -> [0, 0.5, 1]\r\n            }\r\n        }));\r\n        game.newGame();\r\n        mcts.init(_.cloneDeep(game), net);\r\n    } while(--dataSize > 0);\r\n\r\n    let trainingData = _.flatten(allData);\r\n\r\n    // train\r\n    net.train(trainingData, {\r\n        iterations: 10\r\n    });\r\n}\r\n\r\nagent.save = function() {\r\n    // save\r\n    let save = net.toJSON()\r\n\r\n    // stringify and save JSON Object\r\n    save = JSON.stringify(save);\r\n    fs.writeFile(\"./save.json\", save, 'utf8', function (err) {\r\n        if (err) {\r\n            console.log(\"An error occured while writing JSON Object to File.\");\r\n            return console.log(err);\r\n        }\r\n    \r\n        console.log(\"Agent Updated\");\r\n    });\r\n}\r\n\r\n// plays a game and displays to the console\r\nagent.play = function() {\r\n    while(!game.isDone()) {\r\n        mcts.runSearch(100);\r\n        mcts.updateRoot();\r\n        game.update(mcts.rootMove());\r\n        console.log(game.displayState());\r\n    }\r\n}\r\n\r\n/* Stuff for playing with whomanz */\r\nagent.update = function(move) {\r\n    if(game.isDone()) {\r\n        return;\r\n    }\r\n    let moves = mcts.scores();\r\n    let index = -1;\r\n    for(let i = 0; i < moves.length; i++) {\r\n        if (moves[i].move[0] == move[0] && moves[i].move[1] == move[1]) {\r\n            index = moves[i].index;\r\n            break;\r\n        }\r\n    }\r\n    mcts.updateRoot(index);\r\n    game.update(move);\r\n}\r\n\r\nagent.search = function(size = 100) {\r\n    mcts.runSearch(size);\r\n}\r\n\r\nagent.searchRaw = function(size = 100) {\r\n    mcts.rawSearch(size);\r\n}\r\n\r\nagent.pickMove = function(size = 100) {\r\n    if(game.isDone()) {\r\n        return;\r\n    }\r\n    this.search(size)\r\n    return mcts.bestPlay();\r\n}\r\n\r\nagent.pickMoveRaw = function(size = 100) {\r\n    if(game.isDone()) {\r\n        return;\r\n    }\r\n    this.searchRaw(size)\r\n    return mcts.bestPlay();\r\n}\r\n\r\nagent.newGame = function() {\r\n    game.newGame();\r\n    mcts.init(_.cloneDeep(game), net);\r\n}\r\n\r\nmodule.exports = agent;","// Tic Tac Toe Game Functionality\r\nconst _ = require('lodash');\r\n\r\nconst game = {\r\n    player: 1,\r\n    over: false,\r\n    winner: 0,\r\n    moveCount: 0,\r\n    state: {\r\n        x: Array(9).fill(0),\r\n        o: Array(9).fill(0)\r\n    }\r\n};\r\n\r\ngame.newGame = function() {\r\n    this.state.x = Array(9).fill(0);\r\n    this.state.o = Array(9).fill(0);\r\n    this.player = 1;\r\n    this.over = false;\r\n    this.winner = 0;\r\n    this.moveCount = 0;\r\n};\r\n\r\ngame.getState = function() {\r\n    return this.state;\r\n}\r\n\r\ngame.getPlayer = function() {\r\n    return this.player;\r\n}\r\n\r\ngame.isDone = function() {\r\n    return this.over;\r\n}\r\ngame.getWinner = function() {\r\n    return this.winner;\r\n}\r\n\r\n// converts 2 coordinates to single location (0-8)\r\nfunction _to1D(move) {\r\n    return move[0] + move[1] * 3;\r\n}\r\n\r\n// converts single location to 2 coordinates [0-2][0-2]\r\nfunction _to2D(location) {\r\n    let x = location % 3;\r\n    let y = (location - x)/3;\r\n    return [x,y];\r\n}\r\n\r\n// visual representation\r\ngame.displayState = function() {\r\n    let verbose = \"\";\r\n    this.state.x.forEach((space, i) => {\r\n        // map 0:o, 1:x, 0.5:_\r\n        let xo = (space === 1 ? 'x' : (this.state.o[i] === 1 ? 'o' : '_'));\r\n        // bottom row?\r\n        verbose += i < 6 ? '_' + xo + '_' : ' ' + xo + ' ';\r\n        // next line or barrier?\r\n        verbose += i%3 == 2 ? '\\n' : '|';\r\n    });\r\n\r\n    return verbose;\r\n};\r\n\r\n// Returns all valid moves from current state\r\ngame.validMoves = function() {\r\n    //return all {move, state} from current state\r\n    let moves = [];\r\n\r\n    // loop through each space\r\n    for(let i = 0; i < 9; i++) {\r\n        // check empty\r\n        if(this.state.x[i] == 0 && this.state.o[i] == 0) {\r\n            // copy state and update to next\r\n            let nextState = _.cloneDeep(this.state);\r\n            if(this.player === 1) {\r\n                nextState.x[i] = 1;\r\n            } else {\r\n                nextState.o[i] = 1;\r\n            }\r\n\r\n            // get move location\r\n            let move = _to2D(i);\r\n\r\n            // return both move and state\r\n            moves.push({\r\n                move: move,\r\n                state: nextState\r\n            })\r\n        }\r\n    }\r\n    return moves;\r\n}\r\n\r\n// Update the board to the next position\r\ngame.update = function(move) {\r\n    // Update state\r\n    let position = _to1D(move);\r\n    let focusState;\r\n    if(this.player == 1) {\r\n        focusState = this.state.x;\r\n    } else {\r\n        focusState = this.state.o;\r\n    }\r\n    focusState[position] = 1;\r\n\r\n    // Update isDone\r\n    // Row Check\r\n    this.over = focusState[_to1D([(move[0] + 1)%3, move[1]])] == 1 && focusState[_to1D([(move[0] + 2)%3, move[1]])] == 1;\r\n    // Column Check\r\n    if (!this.over) {\r\n        this.over = focusState[_to1D([move[0], (move[1] + 1)%3])] == 1 && focusState[_to1D([move[0], (move[1] + 2)%3])] == 1;\r\n    }\r\n    // Diagonals\r\n    if(!this.over && position%2 == 0) {\r\n        this.over = (focusState[0] == 1 && focusState[4] == 1 && focusState[8] == 1) || (focusState[2] == 1 && focusState[4] == 1 && focusState[6] == 1);\r\n    }\r\n    // Draw\r\n    if(!this.over) {\r\n        this.over = this.moveCount == 8;\r\n    } else {\r\n        // Set winner if one\r\n        this.winner = this.player;\r\n    }\r\n    \r\n    this.player = -this.player;\r\n    this.moveCount++;\r\n    return this.over;\r\n}\r\n\r\nmodule.exports = game;","const nodeFactory = require('./mctsNode.js');\r\nconst _ = require('lodash');\r\n\r\n// Monte Carlo Tree Search\r\nconst mcts = {};\r\nmcts.init = function(game, network) {\r\n    this.game = game;\r\n    this.root = nodeFactory.newNode(null, null, game.getState(), game.validMoves());\r\n    this.net = network;\r\n}\r\n\r\n// Generate the tree from the current root\r\nmcts.runSearch = function(totalIterations = 1000, exploration = 1.4) {\r\n    let iterations = 0;\r\n    // build the tree\r\n    do {\r\n        let currentNode = this.root;\r\n        let newNode = false;\r\n        let game = _.cloneDeep(this.game);\r\n        // phase 1: traverse the tree to an endpoint \r\n        // and phase 2: add a new node\r\n        do {\r\n            if(game.isDone()) {\r\n                break;\r\n            }\r\n            // choose next child\r\n            let confidence = -1;\r\n            let chosen;\r\n            currentNode.children.forEach(child => {\r\n                if(newNode) {return;}\r\n                // ultimate search condition\r\n                if(child.node == null) {\r\n                    // create new node\r\n                    game.update(child.move);\r\n                    child.node = nodeFactory.newNode(currentNode, child.move, game.getState(), game.validMoves());\r\n                    newNode = true;\r\n                    chosen = child.node;\r\n                } else { \r\n                    // UCB1 selection function. Basically balances best moves with exploration\r\n                    let newConfidence = child.node.wins / child.node.plays + \r\n                        exploration * Math.sqrt(Math.log(currentNode.plays) / child.node.plays)\r\n                    if(newConfidence > confidence) {\r\n                        chosen = child.node;\r\n                        confidence = newConfidence;\r\n                    }\r\n                }\r\n            });\r\n            currentNode = chosen;\r\n            if(!newNode) {\r\n                game.update(chosen.move);\r\n            }\r\n        } while(!newNode);\r\n\r\n        // needed for phase 4\r\n        let nodePlayer = game.getPlayer();\r\n\r\n        // phase 3: simulate a game\r\n        while(!game.isDone()) {\r\n            // return value of each state\r\n            let moves = game.validMoves();\r\n            let moveValue = moves.map(move => {\r\n                let input = _.concat(move.state.x, move.state.o);\r\n                let output = this.net.run(input);\r\n                // Covers loaded nets returning objects\r\n                if(typeof output != 'number') { \r\n                    output = output[0];\r\n                }\r\n                // flip probs for o\r\n                if(game.getPlayer() != 1) {\r\n                    output = 1 - output;\r\n                }\r\n                return output;\r\n            });\r\n            let bestMove = 0;\r\n            for(let i = 1; i < moveValue.length; i++) {\r\n                if (moveValue[i] > moveValue[bestMove]) {\r\n                    bestMove = i;\r\n                }\r\n            }\r\n            game.update(moves[bestMove].move);\r\n        }\r\n\r\n        // phase 4: backpropagation\r\n        if(game.getWinner() == 0.5) {\r\n            do {\r\n                currentNode.plays += 1;\r\n                currentNode.wins += 0.5;\r\n                currentNode = currentNode.parent;\r\n            } while(currentNode != null) \r\n        } else {\r\n            let reward = game.getWinner() == nodePlayer ? 0 : 1;\r\n            do {\r\n                currentNode.plays += 1;\r\n                currentNode.wins += reward;\r\n                reward = Math.abs(reward - 1); // alternates between 0 and 1\r\n                currentNode = currentNode.parent;\r\n            } while(currentNode != null);\r\n        }\r\n\r\n    } while(++iterations < totalIterations);\r\n};\r\n\r\n// Generate the tree from the current root (but simulates with random moves)\r\nmcts.rawSearch = function(totalIterations = 1000, exploration = 1.4) {\r\n    let iterations = 0;\r\n    // build the tree\r\n    do {\r\n        let currentNode = this.root;\r\n        let newNode = false;\r\n        let game = _.cloneDeep(this.game);\r\n        // phase 1: traverse the tree to an endpoint \r\n        // and phase 2: add a new node\r\n        do {\r\n            if(game.isDone()) {\r\n                break;\r\n            }\r\n            // choose next child\r\n            let confidence = -1;\r\n            let chosen;\r\n            currentNode.children.forEach(child => {\r\n                if(newNode) {return;}\r\n                // ultimate search condition\r\n                if(child.node == null) {\r\n                    // create new node\r\n                    game.update(child.move);\r\n                    child.node = nodeFactory.newNode(currentNode, child.move, game.getState(), game.validMoves());\r\n                    newNode = true;\r\n                    chosen = child.node;\r\n                } else { \r\n                    // UCB1 selection function. Basically balances best moves with exploration\r\n                    let newConfidence = child.node.wins / child.node.plays + \r\n                        exploration * Math.sqrt(Math.log(currentNode.plays) / child.node.plays)\r\n                    if(newConfidence > confidence) {\r\n                        chosen = child.node;\r\n                        confidence = newConfidence;\r\n                    }\r\n                }\r\n            });\r\n            currentNode = chosen;\r\n            if(!newNode) {\r\n                game.update(chosen.move);\r\n            }\r\n        } while(!newNode);\r\n\r\n        // needed for phase 4\r\n        let nodePlayer = game.getPlayer();\r\n\r\n        // phase 3: simulate a game\r\n        while(!game.isDone()) {\r\n            // return value of each state\r\n            const moves = game.validMoves();\r\n            const picked = Math.floor(Math.random() * moves.length)\r\n            game.update(moves[picked].move);\r\n        }\r\n\r\n        // phase 4: backpropagation\r\n        if(game.getWinner() == 0.5) {\r\n            do {\r\n                currentNode.plays += 1;\r\n                currentNode.wins += 0.5;\r\n                currentNode = currentNode.parent;\r\n            } while(currentNode != null) \r\n        } else {\r\n            let reward = game.getWinner() == nodePlayer ? 0 : 1;\r\n            do {\r\n                currentNode.plays += 1;\r\n                currentNode.wins += reward;\r\n                reward = Math.abs(reward - 1); // alternates between 0 and 1\r\n                currentNode = currentNode.parent;\r\n            } while(currentNode != null);\r\n        }\r\n\r\n    } while(++iterations < totalIterations);\r\n};\r\n\r\nfunction _bestChild(node) {\r\n    let best = node.children[0];\r\n    let score = 0;\r\n    node.children.forEach(child => {\r\n        let childScore = child.node.wins / child.node.plays\r\n        if(childScore > score) {\r\n            best = child;\r\n            score = childScore;\r\n        }\r\n    });\r\n    return best;\r\n}\r\n\r\n// retun the current winningest child\r\nmcts.bestPlay = function() {\r\n    return _bestChild(this.root).move;\r\n};\r\n\r\n// returns scores of all children\r\nmcts.scores = function() {\r\n    return this.root.children.map((child, index) => {\r\n        return {\r\n            value: child.node.wins / child.node.plays,\r\n            index,\r\n            move: child.move\r\n        }\r\n    })\r\n}\r\n\r\n// Set the root to be the winningest child\r\nmcts.updateRoot = function(child = -1) {\r\n    // update root\r\n    if(child < 0) {\r\n        this.root = _bestChild(this.root).node;\r\n    } else {\r\n        this.root = this.root.children[child].node;\r\n    }\r\n    \r\n    // update game\r\n    this.game.update(this.root.move);\r\n\r\n    // remove parent (to save on backprop)\r\n    this.root.parent = null;\r\n};\r\n\r\nmcts.rootMove = function() {\r\n    return this.root.move;\r\n}\r\n\r\nmodule.exports = mcts;","// node factory for mcts\r\n// thought this would be bigger, could probably reside in mtcs.js\r\nconst nodeFactory = {};\r\nnodeFactory.newNode = (parent, move, state, childMoves) => {\r\n    const node = {\r\n        move,\r\n        state,\r\n        plays: 0,\r\n        wins: 0,\r\n        parent\r\n    }\r\n\r\n    // move comes with move and state\r\n    node.children = childMoves.map((move) => {\r\n        return {move: move.move, node: null};\r\n    })\r\n\r\n    return node;\r\n};\r\n\r\nmodule.exports = nodeFactory;"],"sourceRoot":""}